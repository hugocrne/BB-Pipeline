# Dry Run System - Syst√®me de Simulation

## English Documentation

### Overview

The Dry Run System is a comprehensive simulation framework designed for the BB-Pipeline project. It provides complete simulation capabilities without executing actual pipeline operations, enabling users to validate configurations, estimate resource usage, analyze performance profiles, and optimize execution plans before running real operations.

### Key Features

#### Multiple Simulation Modes

- **Validation Only**: Comprehensive configuration and dependency validation
- **Resource Estimation**: Detailed analysis of CPU, memory, disk, and network requirements  
- **Full Simulation**: Complete end-to-end simulation with performance profiling
- **Interactive Mode**: User-guided simulation with confirmation prompts
- **Performance Profiling**: In-depth performance analysis and bottleneck identification

#### Advanced Validation

- **Configuration Validation**: Pipeline configuration syntax and structure validation
- **Dependency Analysis**: Circular dependency detection and resolution order optimization
- **File System Validation**: Input/output file existence and accessibility checks
- **Resource Constraint Validation**: System resource availability and capacity planning
- **Network Simulation**: Simulated network operations with bandwidth estimation

#### Intelligent Resource Estimation

- **CPU Usage Prediction**: Processor utilization estimates based on stage complexity
- **Memory Footprint Analysis**: RAM usage prediction with peak consumption estimates  
- **Disk Space Requirements**: Storage needs assessment for input/output operations
- **Network Bandwidth Usage**: Data transfer requirements and network load analysis
- **Execution Time Estimation**: Duration predictions with confidence intervals
- **I/O Operations Counting**: Input/output operation frequency and patterns

#### Performance Profiling

- **Stage-by-Stage Analysis**: Individual pipeline stage performance characteristics
- **Bottleneck Identification**: System resource constraints and optimization opportunities
- **Parallelization Analysis**: Concurrent execution potential and dependency mapping
- **Critical Path Detection**: Longest execution path identification for optimization
- **Efficiency Scoring**: Performance metrics and improvement recommendations
- **Resource Utilization Patterns**: Usage patterns across different resource types

#### Report Generation

- **HTML Reports**: Rich, interactive web-based reports with charts and graphs
- **JSON Export**: Machine-readable data for integration with external tools
- **Custom Formats**: Extensible report generation with pluggable generators
- **Executive Summaries**: High-level overview for stakeholders and decision makers
- **Technical Details**: Comprehensive technical information for engineers

### Architecture

#### Core Components

1. **DryRunSystem**: Main orchestration class handling simulation execution
2. **DryRunSystemManager**: Singleton manager for global simulation operations
3. **ISimulationEngine**: Pluggable simulation engine interface with default implementation
4. **IReportGenerator**: Customizable report generation system
5. **AutoDryRunGuard**: RAII helper for automatic simulation management

#### Configuration System

```cpp
struct DryRunConfig {
    DryRunMode mode;                           // Simulation execution mode
    SimulationDetail detail_level;            // Level of simulation detail
    bool enable_resource_estimation;          // Enable resource analysis
    bool enable_performance_profiling;        // Enable performance profiling
    bool enable_dependency_validation;        // Enable dependency checking
    bool enable_file_validation;              // Enable file system validation
    bool enable_network_simulation;           // Enable network simulation
    bool show_progress;                       // Show progress during simulation
    bool interactive_mode;                    // Enable interactive confirmations
    bool generate_report;                     // Generate detailed report
    std::string report_output_path;           // Output path for reports
    std::chrono::seconds timeout;             // Maximum simulation duration
    std::unordered_set<std::string> excluded_stages; // Stages to skip
    std::map<std::string, std::string> custom_parameters; // Custom parameters
};
```

#### Simulation Stages

```cpp
struct SimulationStage {
    std::string stage_id;                     // Unique identifier
    std::string stage_name;                   // Human-readable name
    std::string description;                  // Stage description
    std::vector<std::string> dependencies;    // Stage dependencies
    std::chrono::milliseconds estimated_duration; // Execution time estimate
    std::map<ResourceType, double> resource_estimates; // Resource requirements
    std::vector<std::string> input_files;     // Expected input files
    std::vector<std::string> output_files;    // Expected output files
    bool is_optional;                         // Whether stage is optional
    bool can_run_parallel;                    // Supports parallel execution
    std::map<std::string, std::string> metadata; // Additional metadata
};
```

### Usage Examples

#### Basic Setup and Configuration

```cpp
#include "orchestrator/dry_run_system.hpp"

// Create default configuration
BBP::DryRunConfig config = BBP::DryRunUtils::createDefaultConfig();

// Customize configuration
config.mode = BBP::DryRunMode::FULL_SIMULATION;
config.detail_level = BBP::SimulationDetail::DETAILED;
config.enable_resource_estimation = true;
config.enable_performance_profiling = true;
config.generate_report = true;
config.report_output_path = "./simulation_report.html";
config.timeout = std::chrono::minutes(10);

// Create and initialize dry run system
BBP::DryRunSystem dry_run_system(config);
dry_run_system.initialize();
```

#### Pipeline Validation

```cpp
// Validate pipeline configuration only
std::string config_path = "/path/to/pipeline/config.yaml";
auto validation_issues = dry_run_system.validateConfiguration(config_path);

std::cout << "Validation Results:" << std::endl;
for (const auto& issue : validation_issues) {
    std::cout << "[" << BBP::DryRunUtils::severityToString(issue.severity) << "] "
              << issue.category << ": " << issue.message << std::endl;
    
    if (!issue.suggestion.empty()) {
        std::cout << "  Suggestion: " << issue.suggestion << std::endl;
    }
}

// Check if configuration is safe to execute
bool safe_to_execute = std::none_of(validation_issues.begin(), validation_issues.end(),
    [](const auto& issue) {
        return issue.severity == BBP::ValidationSeverity::CRITICAL || 
               issue.severity == BBP::ValidationSeverity::ERROR;
    });

if (safe_to_execute) {
    std::cout << "Configuration is valid and safe to execute." << std::endl;
} else {
    std::cout << "Configuration has critical issues that must be resolved." << std::endl;
}
```

#### Resource Estimation

```cpp
// Load pipeline stages from configuration
auto stages = BBP::DryRunUtils::loadStagesFromConfig(config_path);

// Estimate resource requirements
auto resource_estimates = dry_run_system.estimateResources(stages);

std::cout << "Resource Estimates:" << std::endl;
for (const auto& [resource_type, estimate] : resource_estimates) {
    std::cout << "  " << BBP::DryRunUtils::resourceTypeToString(resource_type) 
              << ": " << estimate.estimated_value << " " << estimate.unit
              << " (confidence: " << estimate.confidence_percentage << "%)" << std::endl;
    std::cout << "    Range: " << estimate.minimum_value 
              << " - " << estimate.maximum_value << " " << estimate.unit << std::endl;
}

// Check for resource constraints
auto memory_estimate = resource_estimates.find(BBP::ResourceType::MEMORY_USAGE);
if (memory_estimate != resource_estimates.end() && 
    memory_estimate->second.estimated_value > 1000.0) { // > 1GB
    std::cout << "Warning: High memory usage expected. Consider optimizing." << std::endl;
}
```

#### Full Simulation with Performance Profiling

```cpp
// Configure for full simulation
BBP::DryRunConfig full_config = BBP::DryRunUtils::createFullSimulationConfig();
dry_run_system.updateConfig(full_config);

// Set up progress monitoring
dry_run_system.setProgressCallback([](const std::string& task, double progress) {
    std::cout << "[" << std::fixed << std::setprecision(1) << progress << "%] " 
              << task << std::endl;
});

// Set up validation monitoring
dry_run_system.setValidationCallback([](const BBP::ValidationIssue& issue) {
    if (issue.severity == BBP::ValidationSeverity::ERROR || 
        issue.severity == BBP::ValidationSeverity::CRITICAL) {
        std::cout << "VALIDATION ERROR: " << issue.message 
                  << " (Stage: " << issue.stage_id << ")" << std::endl;
    }
});

// Set up stage completion monitoring
dry_run_system.setStageCallback([](const std::string& stage_id, 
                                   const BBP::PerformanceProfile& profile) {
    std::cout << "Stage " << stage_id << " simulated:" << std::endl;
    std::cout << "  Wall time: " << profile.wall_time.count() << "ms" << std::endl;
    std::cout << "  CPU usage: " << profile.cpu_utilization << "%" << std::endl;
    std::cout << "  Memory peak: " << profile.memory_peak_mb << "MB" << std::endl;
    std::cout << "  Efficiency: " << (profile.efficiency_score * 100) << "%" << std::endl;
    
    if (!profile.bottlenecks.empty()) {
        std::cout << "  Bottlenecks: ";
        for (size_t i = 0; i < profile.bottlenecks.size(); ++i) {
            if (i > 0) std::cout << ", ";
            std::cout << profile.bottlenecks[i];
        }
        std::cout << std::endl;
    }
});

// Execute full simulation
auto results = dry_run_system.execute(stages);

if (results.success) {
    std::cout << "Simulation completed successfully in " 
              << results.simulation_duration.count() << "ms" << std::endl;
    
    // Analyze execution plan
    const auto& plan = results.execution_plan;
    std::cout << "Execution Plan Analysis:" << std::endl;
    std::cout << "  Total estimated time: " << plan.total_estimated_time.count() << "ms" << std::endl;
    std::cout << "  Parallelization factor: " << plan.parallelization_factor << std::endl;
    std::cout << "  Critical path: " << plan.critical_path << std::endl;
    
    // Show optimization recommendations
    if (!results.recommendations.empty()) {
        std::cout << "Optimization Recommendations:" << std::endl;
        for (const auto& recommendation : results.recommendations) {
            std::cout << "  - " << recommendation << std::endl;
        }
    }
} else {
    std::cout << "Simulation failed. Check validation issues." << std::endl;
}
```

#### Interactive Mode

```cpp
// Configure for interactive mode
BBP::DryRunConfig interactive_config = config;
interactive_config.mode = BBP::DryRunMode::INTERACTIVE;
interactive_config.interactive_mode = true;
dry_run_system.updateConfig(interactive_config);

// Generate execution plan first
auto execution_plan = dry_run_system.generateExecutionPlan(stages);

// Run interactive confirmation
bool user_approved = dry_run_system.runInteractiveMode(execution_plan);

if (user_approved) {
    std::cout << "User approved execution. Proceeding with actual pipeline..." << std::endl;
    // Here you would proceed with actual pipeline execution
} else {
    std::cout << "User cancelled execution." << std::endl;
}
```

#### Report Generation and Export

```cpp
// Execute simulation
auto results = dry_run_system.execute(stages);

// Generate HTML report
std::string html_report = dry_run_system.generateReport(results, "html");
std::cout << "Generated HTML report (" << html_report.length() << " characters)" << std::endl;

// Generate JSON report for programmatic access
std::string json_report = dry_run_system.generateReport(results, "json");

// Export reports to files
std::string html_file = "./simulation_report.html";
std::string json_file = "./simulation_report.json";

if (dry_run_system.exportReport(results, html_file, "html")) {
    std::cout << "HTML report exported to: " << html_file << std::endl;
}

if (dry_run_system.exportReport(results, json_file, "json")) {
    std::cout << "JSON report exported to: " << json_file << std::endl;
}

// Parse JSON report for further analysis
try {
    auto json_data = nlohmann::json::parse(json_report);
    auto execution_time = json_data["execution_plan"]["total_estimated_time_ms"].get<int>();
    auto success = json_data["success"].get<bool>();
    
    std::cout << "Parsed from JSON report:" << std::endl;
    std::cout << "  Success: " << (success ? "Yes" : "No") << std::endl;
    std::cout << "  Total time: " << execution_time << "ms" << std::endl;
} catch (const std::exception& e) {
    std::cout << "Error parsing JSON report: " << e.what() << std::endl;
}
```

#### Using AutoDryRunGuard

```cpp
{
    // RAII automatic dry run execution
    BBP::AutoDryRunGuard guard(config_path, BBP::DryRunMode::VALIDATE_ONLY);
    
    // Check if execution would be safe
    if (guard.isSafeToExecute()) {
        std::cout << "Pipeline is safe to execute." << std::endl;
        
        // Get detailed execution plan
        auto plan = guard.getExecutionPlan();
        std::cout << "Estimated execution time: " 
                  << plan.total_estimated_time.count() << "ms" << std::endl;
        
        // Proceed with actual execution (your pipeline code here)
        // executePipeline(config_path);
    } else {
        std::cout << "Pipeline has validation issues:" << std::endl;
        auto issues = guard.getValidationIssues();
        for (const auto& issue : issues) {
            if (issue.severity == BBP::ValidationSeverity::ERROR || 
                issue.severity == BBP::ValidationSeverity::CRITICAL) {
                std::cout << "  - " << issue.message << std::endl;
            }
        }
    }
    
    // Guard destructor automatically executes simulation if not done manually
}
```

#### Global Manager Usage

```cpp
// Initialize global manager
auto& manager = BBP::DryRunSystemManager::getInstance();
manager.initialize(config);

// Quick validation check
auto quick_issues = manager.quickValidate(config_path);
bool has_critical_issues = std::any_of(quick_issues.begin(), quick_issues.end(),
    [](const auto& issue) {
        return issue.severity == BBP::ValidationSeverity::CRITICAL;
    });

if (!has_critical_issues) {
    // Get resource estimates
    auto estimates = manager.getResourceEstimates(config_path);
    
    // Generate execution preview
    auto preview = manager.generatePreview(config_path);
    
    // Check overall system readiness
    bool system_ready = manager.checkSystemReadiness(config_path);
    
    std::cout << "System readiness check: " << (system_ready ? "READY" : "NOT READY") << std::endl;
}
```

#### Custom Simulation Engine

```cpp
// Implement custom simulation engine
class CustomSimulationEngine : public BBP::detail::ISimulationEngine {
public:
    bool initialize(const BBP::DryRunConfig& config) override {
        // Custom initialization logic
        return true;
    }
    
    BBP::PerformanceProfile simulateStage(const BBP::SimulationStage& stage) override {
        // Custom stage simulation logic
        BBP::PerformanceProfile profile;
        profile.stage_id = stage.stage_id;
        
        // Your custom performance modeling here
        profile.wall_time = std::chrono::milliseconds(stage.estimated_duration.count() * 1.2);
        profile.cpu_time = std::chrono::milliseconds(profile.wall_time.count() * 0.8);
        profile.cpu_utilization = 65.0;
        profile.memory_peak_mb = 256;
        profile.efficiency_score = 0.85;
        
        return profile;
    }
    
    // Implement other required methods...
};

// Register custom engine
auto custom_engine = std::make_unique<CustomSimulationEngine>();
dry_run_system.registerSimulationEngine(std::move(custom_engine));
```

#### Custom Report Generator

```cpp
// Implement custom report generator
class CustomReportGenerator : public BBP::detail::IReportGenerator {
public:
    std::string generateReport(const BBP::DryRunResults& results) override {
        std::stringstream report;
        report << "=== CUSTOM SIMULATION REPORT ===" << std::endl;
        report << "Success: " << (results.success ? "YES" : "NO") << std::endl;
        report << "Duration: " << results.simulation_duration.count() << "ms" << std::endl;
        report << "Stages: " << results.execution_plan.stages.size() << std::endl;
        
        // Add custom analysis and formatting
        
        return report.str();
    }
    
    bool exportToFile(const std::string& report, const std::string& file_path) override {
        std::ofstream file(file_path);
        if (file.is_open()) {
            file << report;
            return true;
        }
        return false;
    }
};

// Register custom generator
auto custom_generator = std::make_unique<CustomReportGenerator>();
dry_run_system.registerReportGenerator("custom", std::move(custom_generator));

// Use custom report format
std::string custom_report = dry_run_system.generateReport(results, "custom");
```

### Advanced Features

#### Dependency Analysis and Optimization

```cpp
// Analyze stage dependencies
auto dependency_graph = BBP::DryRunUtils::generateDependencyGraph(stages);

// Check for circular dependencies
auto circular_deps = BBP::DryRunUtils::findCircularDependencies(stages);
if (!circular_deps.empty()) {
    std::cout << "Warning: Circular dependencies detected:" << std::endl;
    for (const auto& cycle : circular_deps) {
        std::cout << "  Cycle: ";
        for (size_t i = 0; i < cycle.size(); ++i) {
            if (i > 0) std::cout << " -> ";
            std::cout << cycle[i];
        }
        std::cout << std::endl;
    }
}

// Optimize execution plan
auto original_plan = dry_run_system.generateExecutionPlan(stages);
auto optimized_plan = BBP::DryRunUtils::optimizeExecutionPlan(original_plan);

std::cout << "Optimization Results:" << std::endl;
std::cout << "  Original parallelization factor: " << original_plan.parallelization_factor << std::endl;
std::cout << "  Optimized parallelization factor: " << optimized_plan.parallelization_factor << std::endl;
```

#### Performance Benchmarking

```cpp
// Benchmark different configurations
std::vector<BBP::DryRunConfig> configs = {
    BBP::DryRunUtils::createValidationOnlyConfig(),
    BBP::DryRunUtils::createFullSimulationConfig(),
    BBP::DryRunUtils::createPerformanceProfilingConfig()
};

for (const auto& test_config : configs) {
    dry_run_system.updateConfig(test_config);
    
    auto start_time = std::chrono::high_resolution_clock::now();
    auto results = dry_run_system.execute(stages);
    auto end_time = std::chrono::high_resolution_clock::now();
    
    auto benchmark_duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end_time - start_time);
    
    std::cout << "Config mode " << static_cast<int>(test_config.mode) 
              << " took " << benchmark_duration.count() << "ms" << std::endl;
}
```

### Performance Considerations

#### Simulation Performance

- **Configuration Optimization**: Choose appropriate simulation detail levels
- **Resource Estimation Accuracy**: Balance between accuracy and computation time
- **Parallel Simulation**: Utilize multi-threading for stage simulation where possible
- **Caching**: Cache simulation results for repeated executions
- **Memory Management**: Efficient memory usage during large pipeline simulations

#### Accuracy Tuning

- **Estimation Models**: Calibrate resource estimation models based on historical data
- **Confidence Intervals**: Use confidence levels to communicate estimation uncertainty
- **Validation Feedback**: Incorporate actual execution results to improve predictions
- **Custom Engines**: Implement domain-specific simulation engines for better accuracy

#### Scalability

- **Large Pipelines**: Handle pipelines with hundreds of stages efficiently
- **Distributed Simulation**: Support for distributed simulation across multiple nodes
- **Stream Processing**: Process large configuration files without loading entirely into memory
- **Progress Monitoring**: Real-time progress updates for long-running simulations

---

## Documentation Fran√ßaise

### Aper√ßu

Le Syst√®me de Simulation est un framework de simulation complet con√ßu pour le projet BB-Pipeline. Il fournit des capacit√©s de simulation compl√®tes sans ex√©cuter les op√©rations r√©elles du pipeline, permettant aux utilisateurs de valider les configurations, estimer l'utilisation des ressources, analyser les profils de performance et optimiser les plans d'ex√©cution avant d'ex√©cuter les op√©rations r√©elles.

### Fonctionnalit√©s Principales

#### Modes de Simulation Multiples

- **Validation Uniquement**: Validation compl√®te de configuration et d√©pendances
- **Estimation de Ressources**: Analyse d√©taill√©e des besoins CPU, m√©moire, disque et r√©seau
- **Simulation Compl√®te**: Simulation bout-en-bout compl√®te avec profilage de performance
- **Mode Interactif**: Simulation guid√©e par l'utilisateur avec invites de confirmation
- **Profilage de Performance**: Analyse de performance approfondie et identification des goulots d'√©tranglement

#### Validation Avanc√©e

- **Validation de Configuration**: Validation de syntaxe et structure de configuration de pipeline
- **Analyse de D√©pendances**: D√©tection de d√©pendances circulaires et optimisation d'ordre de r√©solution
- **Validation Syst√®me de Fichiers**: V√©rifications d'existence et accessibilit√© des fichiers d'entr√©e/sortie
- **Validation de Contraintes de Ressources**: Disponibilit√© des ressources syst√®me et planification de capacit√©
- **Simulation R√©seau**: Op√©rations r√©seau simul√©es avec estimation de bande passante

#### Estimation de Ressources Intelligente

- **Pr√©diction Utilisation CPU**: Estimations d'utilisation processeur bas√©es sur la complexit√© des √©tapes
- **Analyse Empreinte M√©moire**: Pr√©diction d'usage RAM avec estimations de consommation de pointe
- **Besoins Espace Disque**: √âvaluation des besoins de stockage pour les op√©rations d'entr√©e/sortie
- **Usage Bande Passante R√©seau**: Analyse des besoins de transfert de donn√©es et charge r√©seau
- **Estimation Temps d'Ex√©cution**: Pr√©dictions de dur√©e avec intervalles de confiance
- **Comptage Op√©rations E/S**: Fr√©quence et patterns des op√©rations d'entr√©e/sortie

#### Profilage de Performance

- **Analyse √âtape par √âtape**: Caract√©ristiques de performance des √©tapes individuelles du pipeline
- **Identification des Goulots d'√âtranglement**: Contraintes de ressources syst√®me et opportunit√©s d'optimisation
- **Analyse de Parall√©lisation**: Potentiel d'ex√©cution concurrente et cartographie des d√©pendances
- **D√©tection du Chemin Critique**: Identification du chemin d'ex√©cution le plus long pour optimisation
- **Notation d'Efficacit√©**: M√©triques de performance et recommandations d'am√©lioration
- **Patterns d'Utilisation de Ressources**: Patterns d'usage sur diff√©rents types de ressources

#### G√©n√©ration de Rapports

- **Rapports HTML**: Rapports web riches et interactifs avec graphiques et diagrammes
- **Export JSON**: Donn√©es lisibles par machine pour int√©gration avec outils externes
- **Formats Personnalis√©s**: G√©n√©ration de rapports extensible avec g√©n√©rateurs pluggables
- **R√©sum√©s Ex√©cutifs**: Aper√ßu de haut niveau pour parties prenantes et d√©cideurs
- **D√©tails Techniques**: Information technique compl√®te pour les ing√©nieurs

### Architecture

#### Composants Principaux

1. **DryRunSystem**: Classe d'orchestration principale g√©rant l'ex√©cution de simulation
2. **DryRunSystemManager**: Gestionnaire singleton pour op√©rations de simulation globales
3. **ISimulationEngine**: Interface de moteur de simulation pluggable avec impl√©mentation par d√©faut
4. **IReportGenerator**: Syst√®me de g√©n√©ration de rapports personnalisable
5. **AutoDryRunGuard**: Helper RAII pour gestion automatique de simulation

### Exemples d'Usage

#### Configuration et Installation de Base

```cpp
#include "orchestrator/dry_run_system.hpp"

// Cr√©e la configuration par d√©faut
BBP::DryRunConfig config = BBP::DryRunUtils::createDefaultConfig();

// Personnalise la configuration
config.mode = BBP::DryRunMode::FULL_SIMULATION;
config.detail_level = BBP::SimulationDetail::DETAILED;
config.enable_resource_estimation = true;
config.enable_performance_profiling = true;
config.generate_report = true;
config.report_output_path = "./rapport_simulation.html";
config.timeout = std::chrono::minutes(10);

// Cr√©e et initialise le syst√®me de simulation
BBP::DryRunSystem dry_run_system(config);
dry_run_system.initialize();
```

#### Validation de Pipeline

```cpp
// Valide seulement la configuration du pipeline
std::string config_path = "/chemin/vers/config/pipeline.yaml";
auto problemes_validation = dry_run_system.validateConfiguration(config_path);

std::cout << "R√©sultats de Validation:" << std::endl;
for (const auto& probleme : problemes_validation) {
    std::cout << "[" << BBP::DryRunUtils::severityToString(probleme.severity) << "] "
              << probleme.category << ": " << probleme.message << std::endl;
    
    if (!probleme.suggestion.empty()) {
        std::cout << "  Suggestion: " << probleme.suggestion << std::endl;
    }
}

// V√©rifie si la configuration est s√ªre √† ex√©cuter
bool sur_a_executer = std::none_of(problemes_validation.begin(), problemes_validation.end(),
    [](const auto& probleme) {
        return probleme.severity == BBP::ValidationSeverity::CRITICAL || 
               probleme.severity == BBP::ValidationSeverity::ERROR;
    });

if (sur_a_executer) {
    std::cout << "La configuration est valide et s√ªre √† ex√©cuter." << std::endl;
} else {
    std::cout << "La configuration a des probl√®mes critiques qui doivent √™tre r√©solus." << std::endl;
}
```

#### Estimation de Ressources

```cpp
// Charge les √©tapes du pipeline depuis la configuration
auto stages = BBP::DryRunUtils::loadStagesFromConfig(config_path);

// Estime les besoins en ressources
auto estimations_ressources = dry_run_system.estimateResources(stages);

std::cout << "Estimations de Ressources:" << std::endl;
for (const auto& [type_ressource, estimation] : estimations_ressources) {
    std::cout << "  " << BBP::DryRunUtils::resourceTypeToString(type_ressource) 
              << ": " << estimation.estimated_value << " " << estimation.unit
              << " (confiance: " << estimation.confidence_percentage << "%)" << std::endl;
    std::cout << "    Plage: " << estimation.minimum_value 
              << " - " << estimation.maximum_value << " " << estimation.unit << std::endl;
}

// V√©rifie les contraintes de ressources
auto estimation_memoire = estimations_ressources.find(BBP::ResourceType::MEMORY_USAGE);
if (estimation_memoire != estimations_ressources.end() && 
    estimation_memoire->second.estimated_value > 1000.0) { // > 1GB
    std::cout << "Attention: Utilisation m√©moire √©lev√©e attendue. Consid√©rez l'optimisation." << std::endl;
}
```

### API Reference

#### Classe DryRunSystem

**Constructeur**
```cpp
explicit DryRunSystem(const DryRunConfig& config = DryRunConfig{});
```

**M√©thodes Principales**
```cpp
bool initialize();
void shutdown();
DryRunResults execute(const std::vector<SimulationStage>& stages);
DryRunResults executeForPipeline(const std::string& pipeline_config_path);
std::vector<ValidationIssue> validateConfiguration(const std::string& config_path);
std::map<ResourceType, ResourceEstimate> estimateResources(const std::vector<SimulationStage>& stages);
ExecutionPlan generateExecutionPlan(const std::vector<SimulationStage>& stages);
PerformanceProfile simulateStage(const SimulationStage& stage);
```

**M√©thodes de Gestion**
```cpp
bool runInteractiveMode(const ExecutionPlan& plan);
std::string generateReport(const DryRunResults& results, const std::string& format = "html");
bool exportReport(const DryRunResults& results, const std::string& file_path, const std::string& format = "html");
void updateConfig(const DryRunConfig& config);
const DryRunConfig& getConfig() const;
```

**Callbacks**
```cpp
void setProgressCallback(std::function<void(const std::string&, double)> callback);
void setValidationCallback(std::function<void(const ValidationIssue&)> callback);
void setStageCallback(std::function<void(const std::string&, const PerformanceProfile&)> callback);
```

**Enregistrement d'Extensions**
```cpp
void registerSimulationEngine(std::unique_ptr<detail::ISimulationEngine> engine);
void registerReportGenerator(const std::string& format, std::unique_ptr<detail::IReportGenerator> generator);
```

#### Classe DryRunSystemManager

```cpp
static DryRunSystemManager& getInstance();
bool initialize(const DryRunConfig& config = DryRunConfig{});
void shutdown();
DryRunSystem& getDryRunSystem();
std::vector<ValidationIssue> quickValidate(const std::string& config_path);
std::map<ResourceType, ResourceEstimate> getResourceEstimates(const std::string& config_path);
ExecutionPlan generatePreview(const std::string& config_path);
bool checkSystemReadiness(const std::string& config_path);
```

#### Classe AutoDryRunGuard

```cpp
AutoDryRunGuard(const std::string& config_path, DryRunMode mode = DryRunMode::VALIDATE_ONLY);
AutoDryRunGuard(const std::vector<SimulationStage>& stages, DryRunMode mode = DryRunMode::VALIDATE_ONLY);
DryRunResults execute();
bool isSafeToExecute() const;
std::vector<ValidationIssue> getValidationIssues() const;
ExecutionPlan getExecutionPlan() const;
```

### Gestion d'Erreurs

Le syst√®me de simulation fournit une gestion d'erreurs compl√®te √† travers :

- **S√©curit√© d'Exception**: Toutes les op√©rations sont s√ªres aux exceptions avec nettoyage appropri√© des ressources
- **Validation**: Validation d'entr√©e pour toutes les m√©thodes publiques
- **Logging**: Logging d√©taill√© des erreurs et tentatives de r√©cup√©ration
- **D√©gradation Gracieuse**: Le syst√®me continue de fonctionner m√™me si la simulation √©choue
- **V√©rification de R√©cup√©ration**: V√©rification automatique de l'int√©grit√© de l'√©tat r√©cup√©r√©

### Thread Safety

Le syst√®me de simulation est compl√®tement thread-safe :

- **Acc√®s Concurrent**: Plusieurs threads peuvent acc√©der en s√©curit√© √† la m√™me instance DryRunSystem
- **Op√©rations Atomiques**: Tous les changements d'√©tat sont atomiques
- **Chemins Sans Verrous**: Les op√©rations en lecture seule utilisent des impl√©mentations sans verrous quand possible
- **Pr√©vention de Deadlock**: Ordonnancement de verrous soigneux pour √©viter les sc√©narios de deadlock

### Int√©gration avec BB-Pipeline

Le syst√®me de simulation s'int√®gre parfaitement avec le framework BB-Pipeline :

- **Int√©gration Pipeline Engine**: Int√©gration directe avec PipelineEngine pour simulation automatique
- **Compatibilit√© Modules CSV**: Pr√©serve l'√©tat de traitement CSV et r√©sultats interm√©diaires
- **Syst√®me de Configuration**: Utilise la gestion de configuration de BB-Pipeline
- **Int√©gration Logging**: Utilise le syst√®me de logging structur√© de BB-Pipeline

### Consid√©rations de Performance

#### Performance de Simulation

- **Optimisation Configuration**: Choisir des niveaux de d√©tail de simulation appropri√©s
- **Pr√©cision Estimation Ressources**: √âquilibre entre pr√©cision et temps de calcul
- **Simulation Parall√®le**: Utilise le multi-threading pour simulation d'√©tapes quand possible
- **Mise en Cache**: Met en cache les r√©sultats de simulation pour ex√©cutions r√©p√©t√©es
- **Gestion M√©moire**: Usage efficace de la m√©moire pendant les simulations de gros pipelines

#### R√©glage de Pr√©cision

- **Mod√®les d'Estimation**: Calibre les mod√®les d'estimation de ressources bas√©s sur donn√©es historiques
- **Intervalles de Confiance**: Utilise les niveaux de confiance pour communiquer l'incertitude d'estimation
- **Feedback de Validation**: Incorpore les r√©sultats d'ex√©cution r√©els pour am√©liorer les pr√©dictions
- **Moteurs Personnalis√©s**: Impl√©mente des moteurs de simulation sp√©cifiques au domaine pour meilleure pr√©cision

#### √âvolutivit√©

- **Gros Pipelines**: G√®re les pipelines avec des centaines d'√©tapes efficacement
- **Simulation Distribu√©e**: Support pour simulation distribu√©e sur plusieurs n≈ìuds
- **Traitement de Flux**: Traite les gros fichiers de configuration sans charger enti√®rement en m√©moire
- **Monitoring de Progression**: Mises √† jour de progression en temps r√©el pour simulations de longue dur√©e

### Troubleshooting

#### Probl√®mes Courants

**√âchec de Validation de Configuration**
- V√©rifiez la syntaxe YAML/JSON de la configuration
- Validez les chemins de fichiers et permissions
- Assurez-vous que toutes les d√©pendances requises sont sp√©cifi√©es

**Estimations de Ressources Inexactes**
- Calibrez les param√®tres du moteur de simulation
- Fournissez des m√©tadonn√©es de complexit√© d'√©tape plus pr√©cises
- Utilisez des moteurs de simulation personnalis√©s pour domaines sp√©cifiques

**Performance de Simulation Lente**
- R√©duisez le niveau de d√©tail de simulation
- D√©sactivez le profilage de performance pour validation simple
- Utilisez la mise en cache pour configurations r√©p√©t√©es

**Probl√®mes de G√©n√©ration de Rapport**
- V√©rifiez les permissions d'√©criture du r√©pertoire de sortie
- Assurez-vous que l'espace disque suffisant est disponible
- Validez le format de rapport demand√©

#### Information de Debug

Activez le logging d√©taill√© pour obtenir une information de debug compl√®te :

```cpp
dry_run_system.setDetailedLogging(true);
```

V√©rifiez les statistiques pour des insights de performance :

```cpp
auto stats = dry_run_system.getSimulationStatistics();
for (const auto& [key, value] : stats) {
    std::cout << key << ": " << value << std::endl;
}
```